1	三个坐标轴之间相互垂直 且长度为1 这样的基矢量被称为标准正交基 长度不唯一称为 正交基
2	左手坐标系和右手坐标系之间无法通过旋转来同事使他们的三个坐标轴指向重合
3	描述同样的视觉上的变换 左右手坐标系 数学上的描述是不一样的
4	Unity 在模型空间和世界空间 使用的是左手坐标系
5	Unity 在观察空间（相机空间）使用的是右手坐标系 摄像机的前方向是Z轴的负方向 
  	Z轴越小 物体的深度越大 离摄像机越远
6	矢量：指n维空间中一种包含了模和方向的有向线段
7	点积：a . b = b在a上的投影 X a的长度
8	点积 公式可以直接求矢量的模的平方
9 	点积：夹角小于90度 cos > 0 夹角 等于 90度 cos = 0 夹角大于 90度 cos <0
10 	叉积: a X b = (ax, ay, az) X (bx, by, bz) = (aybz - azby, azbx - axbz, axby - aybx)
11	两个二维向量的叉积的模 |a||b|sin@ == 平行四边形面积
12	3X4矩阵 3行4列
13 	矩阵和标量相乘 就是每个值和标量相乘
14	r X n的矩阵和 n X c的矩阵 相乘结果等于 r X c
15	A矩阵 X B矩阵 = C  C中的Cij = A的第i行的矢量 和 B的第j列矢量点积的结果
16	矩阵乘法不满足交换律 AB != BA
17	矩阵乘法满足结合律 AB(C) = A(BC) ABCDE = ((A(BC))D)E = (AB)(CD)E
18 	对角元素：行号和列号相等的元素
19	对角矩阵：如果一个矩阵除了对角元素外所有的元素都为0 那么这个矩阵就叫对角矩阵
20 	单位矩阵：对角元素都是1的对角矩阵 任何矩阵和他相乘以后还是原来的矩阵 就跟标量中的数字1一样
21	转置矩阵：m = mt rXc -> cXr 原矩阵的第i行变成了第i列 第j行变成了第j列 把原来的矩阵翻转了
22	矩阵转置的转置 = 原矩阵 (Mt)t = M
23	矩阵串接的转置 = 反向串接各个矩阵的转置 (AB)t = BtAt 该性质同样可以扩展到更多矩阵相乘的情况
24	逆矩阵：不是所有的矩阵都有逆矩阵 必须是一个方阵
25	逆矩阵：如果一个矩阵的行列式不为零 那么他就是可逆的 (非奇异的)
26	逆矩阵：可以还原一个变换 或者计算这个变换的反向变换
27	逆矩阵:   MM-1 = I (矩阵乘以自己的逆矩阵 = 单位矩阵)
28	逆矩阵：单位矩阵的逆矩阵 = 单位矩阵
29	转置矩阵的逆矩阵就是逆矩阵的转置 (Mt)-1 = (M-1)t
30	矩阵串接相乘后的逆矩阵 = 反向串接各个矩阵的逆矩阵 (AB)-1 = b-1A-1
31	正交矩阵的转置矩阵和逆矩阵是一样的
32	一组标准正交基可以构造一个正交矩阵
33	在Unity中 常规做法是把矢量放在矩阵的右侧，即把矢量转换成列矩阵来进行运算
34	在和矩阵相乘时 选择行矩阵还是列矩阵来表示矢量是非常重要的 因为这决定了矩阵乘法的书写次序和结	果值
35	CBAv = (C(B(Av))) 先对v使用A进行变换 再使用B进行变换 再使用C进行变换
36	线性变换 旋转和缩放 f(x) +f(y) = f(x + y) kf(x) = f(kx)
37	一个三维矢量 加上w变为 其次坐标 w=1表示点 w=0表示方向
38	约定复合变换顺序 先缩放 再旋转 然后平移 如果先平移再缩放 坐标就不对了
39	行矩阵放在坐标乘 列矩阵放在右边乘
40	变换矩阵Mc->p 可以通过坐标空间C在坐标空间P中的原点和坐标轴的矢量表示来构建出来
	把三个坐标轴依次放入矩阵的前三列，把原点矢量放到最后一列，再用0和1填充最后一行即可
41	当我们已知从模型空间到世界空间的一个4X4的变换矩阵，抽取第一列再进行归一化 来得到该模型空间	的x轴在世界空间下的单位矢量表示
44	投影矩阵：
	1 为投影做准备 可以理解成是一个空间的降维，例如从四维空间投影到三维空间中 真正的投影会发会在屏幕映射时发生，通过齐次除法来得到二维坐标
	2 其次是对x,y,z分量进行缩放，经过投影矩阵的缩放后，我们可以直接使用w分量作为一个范围值，如果x,y,z分量都位于这个范围内，就说明该顶点位于裁剪空间内
	3 如果一个顶点在视锥体内那么它变换后的坐标必须满足 -w<=x<=w -w<=y<=w -w<=z<=w

45	screen_x = clipx * pixelWidth / 2 * clipw + pixelWidth / 2
	screen_y = clipy * pixelHeight / 2 * clipw + pixelHeight / 2
46	切线：通常与纹理空间对齐，与法线垂直
47	法线变换：
	1 如果Ma->b是正交矩阵 可以直接用来变换法线 
	2 如果只包含旋转和统一缩放 用 (1/k) * Ma->b
	3 如果变换中包含了非统一缩放 那么就必须要求解逆转置矩阵来得到变换法线的矩阵

48	mul(M,v) == mul(v, transpose(M))
	mul(v, M) == mul(transpose(M), v)
	mul(Mt,v) == mul(v, M)
49	CG语言是行优先填充数据 即是一行一行地填充数据 Unity脚本中的Matrix4x4是按列优先填充数据
50	一个语义可以使用的寄存器只能处理4个浮点值 因此如果我们想要定义矩阵类型 如 float3X4 float4X4 等变量就需要使用更多的空间
	一种方法是 把这些变量拆分成多个变量 例如对于 float4X4的矩阵类型 我们可以拆分成4个float类型的变量 每个变量存储了矩阵中的一行数据

51	高光反射(specular)部分表示物体表面是如何反射光线的 而漫反射(diffuse)部分则表示有多少光纤会被折射、吸收和散射出表面
52	BRDF Bidirectional Reflectance Distribution Function
53  	标准光照模型 -》自发光 高光反射 漫反射 环境光
54	自发光的表面往往不会照亮周围的表面 也就是说这个物体并不会被当成一个光源 
	Unity5 引入的全新的全局光照系统则可以模拟这类自发光物体对周围物体的影响(PBR)
55	DirectX纹理原点位于左上角 OpenGl纹理原点位于左下角 Unity在绝大多数情况下为我们处理好了这个差异问题
	Unity使用的纹理空间是符合OpenGl的传统的 也就是说 原点位于纹理左下角
56	切线空间原点就是该顶点本身 Z轴是顶点的法线方向  x轴是顶点的切线方向  y轴可由法线和切线叉积而得
	也被称为副切线或副法线  这种纹理被称为是切线空间的法线纹理

57	先渲染不透明物体 并且开启深度测试和深度写入 再把半透明物体按照他们距离摄像机的远近进行排序
	然后按照从后往前的顺序渲染这些半透明物体 并开启他们的深度测试 但关闭深度写入
58	前向渲染路径有3种处理光照（即照亮物体）的方式，逐顶点处理，逐像素处理，球谐函数(SH)处理。
	而决定一个光源使用哪种处理模式取决于它的类型和渲染模式。
59	前向渲染的两种 Pass
	LightMode = ForwardBase 一个逐像素的平行光以及所有逐顶点和SH光源
	#pragma multi_compile_fwdbase
	LightMode = ForwardAdd 其他影响该物体的逐像素光源 每个光源执行一次pass
	#pragma multi_compile_fwdadd
60	每一个光源有5个属性：位置 方向 颜色 强度 衰减
61 	shader的bug 1 向量没有被归一化 2Cutoff不能改名字和大小写 3#pargram 一定要写对 包括空格什么的

















